// GPU-generated vertex shader for plot rendering
// Uses vertices generated by compute shader

struct GpuGeneratedVertex {
    @location(0) position: vec2<f32>,
    @location(1) color: vec4<f32>,
}

struct VertexPayload {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec3<f32>,
}

struct MinMax {
    min_val: f32,
    max_val: f32,
}

struct MinMaxU32 {
    min_val: u32,
    max_val: u32,
}

@group(0) @binding(0) var<uniform> x_min_max: MinMaxU32;
@group(0) @binding(1) var<uniform> y_min_max: MinMax;
@group(0) @binding(2) var<uniform> line_color: vec3<f32>;

@vertex
fn vs_main(vertex: GpuGeneratedVertex) -> VertexPayload {
    var out: VertexPayload;
    
    // The GPU-generated vertex already has X in NDC space
    // We just need to apply the Y value transformation
    out.position.x = vertex.position.x;
    
    // For now, use a default Y position (will be updated when we integrate value data)
    out.position.y = 0.0;
    
    out.position.z = 1.0;
    out.position.w = 1.0;
    
    // Use the color from GPU generation with line color modulation
    out.color = line_color * vertex.color.rgb;
    
    return out;
}

@fragment
fn fs_main(in: VertexPayload) -> @location(0) vec4<f32> {
    return vec4<f32>(in.color, 1.0);
}